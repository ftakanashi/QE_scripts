#!/usr/bin/env python
# -*- coding:utf-8 -*-

NOTE = \
'''
    Accept a .xml file as an input which contains the result of TER analysis generated by tercom.
    Output alignment results based on the TER operations.
    NOTE:
      the alignment generated by this script is based on PE's perspective.
      the indices on MT's side have already adapted to [GAP] inserted MT string, so you may find it a little large.
'''

import argparse
import re
from xml.etree import ElementTree

def process_seg(seg):
    hyp = seg.find('hyp')
    assert hyp is not None
    ter_operations = [t.strip() for t in hyp.text.strip().split('\n')]

    def get_info(line):

        m = re.search('\"(.*?)\",\"(.*?)\",([DISC])', line)
        if m is None:
            raise Exception(f'Invalid line {line}')
        else:
            pe_word = m.group(1)
            mt_word = m.group(2)
            flag = m.group(3)

        pe_word = pe_word[1:-1]    # exclude \"
        mt_word = mt_word[1:-1]
        return pe_word, mt_word, flag

    pe_c = 0
    mt_c = 0
    aligns = []
    for operation in ter_operations:
        # core judgement
        pe_word, mt_word, flag = get_info(operation)
        assert flag in ('D', 'I', 'S', 'C')
        if flag == 'D':
            aligns.append(f'{pe_c}-{mt_c}')
            pe_c += 1
        elif flag == 'S' or flag == 'C':
            mt_c += 1
            aligns.append(f'{pe_c}-{mt_c}')
            pe_c += 1
            mt_c += 1
        elif flag == 'I':
            mt_c += 2

    return aligns


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument('xml_file', help='Path to the input xml file.')

    parser.add_argument('-o', '--output',
                        help='Path to the output alignment file.')

    args = parser.parse_args()

    return args

def main():
    args = parse_args()

    xml_f = open(args.xml_file, 'r')
    tree = ElementTree.parse(xml_f)

    tstset = tree.find('tstset')
    assert tstset is not None

    docs = tstset.findall('doc')
    align_lines = []
    for doc in docs:
        segs = doc.findall('seg')
        for seg in segs:
            aligns = process_seg(seg)
            align_lines.append(' '.join(aligns))


    with open(args.output, 'w') as f:
        for l in align_lines:
            # print(l)    # debug
            f.write(l + '\n')

if __name__ == '__main__':
    main()